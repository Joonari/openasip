#!/usr/bin/env python3
#-*- coding: utf-8 -*-
# 
# Copyright (C) 2022 Tampere University.
# 
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
#
# @author Kari Hepola 2022
#
# RISC-V compiler driver that utilizes LLVM and the OpenASIP backend
#
# Usage: oacc-riscv module1.c module2.c -o module
#
import os, sys, subprocess, optparse, shutil, glob, signal
import os.path
import re

from tempfile import mkdtemp, mkstemp
from optparse import OptionParser
from shutil import rmtree
from shutil import which
from subprocess import Popen, PIPE
from venv import create
from xml.etree import ElementTree as ET

scriptDir = os.path.abspath(os.path.dirname(sys.argv[0]))
runningInstalled = 'src/bintools/Compiler' not in scriptDir or not \
     os.path.exists(os.path.join("@abs_top_builddir@",
                                 "src/applibs/LLVMBackend/passes/.libs/LowerIntrinsics.so"))

### tce install prefix
tceInstalled = True
tceprefix = ""
additionalTmpFiles = []
if 'TCE_INSTALL_DIR' in os.environ.keys():
    tceprefix = os.environ['TCE_INSTALL_DIR']
else:
    (exitCode, output) = subprocess.getstatusoutput("openasip-config --prefix")
    if exitCode != 0:
        tceInstalled = False
    else:
        tceprefix = output

assert not runningInstalled or (tceInstalled and tceprefix != ""), \
        "Could not find TCE prefix. Is TCE installed in PATH?"

def newlibIncludes():
    if runningInstalled:
        return "-I " + os.path.join(tceprefix, "riscv/include")
    else:
        return ( " -I " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libc/include") +
            " -I " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libm/include") + " ")

def newlibLibdir():
    if runningInstalled:
        return os.path.join(tceprefix, "riscv/lib")
    else:
        return os.path.join("@abs_top_builddir@", "newlib-1.17.0/riscv-llvm/riscv/newlib")

#find path for libgcc
def rtLibInclude():
    (exitCode, path) = subprocess.getstatusoutput("riscv32-unknown-elf-gcc -print-libgcc-file-name")
    if exitCode != 0 :
        exitWithError(path)
    return os.path.dirname(path)

def stdLibFlags():
    flags = ""
    flags += "-L " + rtLibInclude() + " "
    flags += "-L " + newlibLibdir() + " "
    return str(flags)

                                                 
def run_command(command, echoStderr=True, echoStdout=True, echoCmd=False):
    """Runs the given shell command and returns its exit code.

    If echoOutput is False, stdout and stderr are redirected to /dev/null."""

    if echoCmd:
        print(command)
    
    from subprocess import Popen, PIPE

    if not echoStdout:
        stdoutRedir = open('/dev/null', 'w')
        stdoutFD = stdoutRedir.fileno()
    else:
        stdoutFD = None

    if not echoStderr:
        stderrRedir = open('/dev/null', 'w')
        stderrFD = stderrRedir.fileno()
    else:
        stderrFD = None

    process = \
       Popen(command, shell=True, stdin=PIPE, stdout=stdoutFD,
             stderr=stderrFD, close_fds=False)
    return process.wait()

tempfiles = []

def hasMExtension(options):
    global MMachine
    MMachine = False
    if options.adf_file != "":
        #TODO: We should check all M extension operations here
        MMachine = ">mul</" in open(options.adf_file).read()
    return MMachine

def create_temp_file(suffix=""):
    tf = mkstemp(suffix=suffix, dir=tempDir)[1]
    tempfiles.append(tf)
    return tf

def cleanup_and_exit(retval=0):
    if not options.leave_tempfiles:
        rmtree(tempDir)
        for i in additionalTmpFiles:
            os.unlink(str(i))
    sys.exit(retval)

def parse_options():
    parser = OptionParser()
    parser.add_option("-o", "--output", dest="output",
                      help="The output file.", metavar="FILE",
                      default=None)

    parser.add_option("-a", "--adf", dest="adf",
                      help="The OpenASIP architecture description format file.", 
                      metavar="FILE", default=None)

    parser.add_option('-O', '--optimization-level',
                      type="int", action="store", metavar='level',
                      dest='optimization_level', default=3,
                      help="Optimization level. O0-O3")

    parser.add_option("-c", "--compile-only", dest="compile_only",
                      action="store_true", default=False,
                      help="Compile only. Do not assemble or link.")

    parser.add_option("-d", "--leave-tempfiles", dest="leave_tempfiles",
                      action="store_true", default=False,
                      help="Do not delete the temporary files.")

    parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                      help="Verbose output. Output the commands executed etc.", default=False)

    parser.add_option('-D', '--preprocessor-define',
                      type="string", action="append", metavar='string',
                      dest="defines", default=[],
                      help="Passed to gcc.")
                      
    parser.add_option('-I', '--include-directory',
                      type="string", action="append", metavar='directory',
                      dest="include_dirs", default=[],
                      help="Passed to gcc.")

    parser.add_option('-l', '--library-name',
                      type="string", action="append", metavar='string',
                      dest="lib_name", default=[],
                      help="Passed to ld.ldd.")

    parser.add_option('-L', '--library-directory',
                      type="string", action="append", metavar='directory',
                      dest="lib_dir", default=[],
                      help="Passed to ld.ldd.")
    
    parser.add_option('-W', '--warning',
                      type="string", action="append", metavar='type',
                      dest="warnings", default=[],
                      help="Ignored.")

    parser.add_option('--unroll-threshold',
                      type="int", action="store", metavar='LLVM_INSTRUCTION_COUNT',
                      dest='unroll_threshold', default=100,
                      help="Unroll loops in case the unrolled loop body size will be less " + \
                      "than the given number of LLVM instructions. Use 0 to disable " + \
                      "loop unrolling.")
    
    parser.add_option('--disable-inlining', action="store_true",
                      dest="noinline", default=False,
                      help="Disable function inlining.")

    parser.add_option('--inline-threshold',
                      type="int", action="store",
                      dest='inline_threshold', default=200,
                      help="Control the amount of inlining.")

    parser.add_option('--extra-llvm-opts',
                      type="string", action="store",
                      metavar='opt1,opt2,opt3', dest='extra_llvm_opts', default="",
                      help="List of additional LLVM passes to run after the regular ones.")

    parser.add_option('--disable-internalize',
                      action="store_true", dest='disable_internalize', default=True,
                      help="Do not internalize (make static) global symbols by default.")

    parser.add_option('-k', '--keep-symbols',
                      type="string", action="store",
                      metavar='sym1,sym2,sym3', dest='keep_symbols', default="",
                      help="List of symbols whose optimization away is prevented. "
                      "If you are using this, remember to define "
                      "at least 'main' symbol.")

    parser.add_option('--output-format',
                      type="string", action="store", metavar='string',
                      dest="output_format", default="",
                      help="Emit program as a text file, bin or hex.")

    parser.add_option('-B',
             type="string", action="append", metavar='directory',
             dest="B_cc_switches", default=[],
             help="Passed to gcc.")

    parser.add_option('-f',
             type="string", action="append", metavar='opt_var',
             dest="f_cc_switches", default=[],
             help="Passed to gcc.")

    parser.add_option('-g',
             action="store_true",
             dest="g_cc_switch", default=False,
             help="Passed to gcc.")
    
    parser.add_option('--isystem',
             type="string", action="append", metavar='directory',
             dest="isystem_cc_switches", default=[],
             help="Passed to gcc as -system switch. Also -isystem is supported.")
    
    parser.add_option('--tce-build-mode', action="store_true",
             dest="tce_build_mode", default=False,
             help="Use when building TCE's bitcode libraries. Sets build directory search paths correctly.")


    # fix gcc switches, which cannot be represented in OptionParser format by adding extra "-" before switch
    args = []
    for opt in sys.argv[1:]:
        if opt.startswith("-isystem"): opt = "-" + opt
        if opt.startswith("-cl-"): opt = "-" + opt
        args.append(opt)

    # parse valid args
    options, args = parser.parse_args(args)

    if options.tce_build_mode:
        # Ensure we find the OSAL directories to produce the tceopgen macros for
        # launching STDOUT etc. from C implementations in newlib.
        os.environ['TCE_DEVEL_MODE'] = '1'
    return (options, args)

def exitWithError(status, errorMessage=None):
    if errorMessage is not None:
        print(errorMessage, sys.stderr)
    if not options.leave_tempfiles:
        rmtree(tempDir)
    sys.exit(status)

def optimizeBytecode(inFile):
    default_passes = "default<O3>"
    if not options.noinline:
        default_passes += ",inline"
        if options.inline_threshold:
            default_opts = "-inline-threshold=%d " % options.inline_threshold
    default_opts += "-unroll-allow-partial -unroll-threshold=%d " % options.unroll_threshold
    optSwitches = ""
    if options.unroll_threshold == 0:
        default_opts += " --disable-loop-unrolling "
    if options.optimization_level == 1 or options.disable_internalize:
        # disable-internalize missing in llvm 3.6
        optSwitches = (default_opts)
    elif options.optimization_level > 1:
        optSwitches = (" -internalize "+ default_opts)
    
    internalize_api_list = " -internalize-public-api-list=" \
                           "_start,_pthread_start,_dthread_start,memcpy"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols

    optSwitches += internalize_api_list

    if options.extra_llvm_opts != "":
        extra_opts = options.extra_llvm_opts.split(',')
        optSwitches += ' -' + ' -'.join(extra_opts)
    outputName = tempDir + "/" + os.path.basename(inFile) + "_optimized.bc"
    #command = "opt -enable-new-pm=0 -passes=\"" + default_passes + '\"' + " -f " + inFile + " -o " + outputName + " " + optSwitches
    command = "opt -passes=\"" + default_passes + '\"' + " -f " + inFile + " -o " + outputName + " " + optSwitches
    exitCode = run_command(command, echoCmd=options.verbose)
    if exitCode != 0:
        exitWithError(1, "Error while optimizing bytecode: " + command + "\n")
    return outputName

def assemble(input_files, output_file=""):
    compileFlags = ""
    output_files = []
    if options.g_cc_switch:
        compileFlags += "-g "
    for i in options.include_dirs:
        compileFlags += "-I" + i + " "
    for i in options.defines:
        compileFlags += "-D" + i + " "
    march = "-march=rv32i"
    if hasMExtension :
        march += "m"
    if output_file != "":
        compileFlags += "-o " + output_file + " "
    inputArgs = " ".join(input_files)
    obj_file_name = output_file
    if output_file == "":
        for input_file in input_files:
            #Change extension
            obj_file_name = os.path.splitext(input_file)[0]
            obj_file_name = obj_file_name + ".o"
            #Get basename, clang will emit the file in current dir
            obj_file_name = os.path.basename(obj_file_name)
            output_files.append(obj_file_name)
    else:
        output_files.append(obj_file_name)
    retval = \
        run_command("clang -D__OA_RISCV__ -I %s %s -target riscv32 %s -O3 -c %s" % \
        (tempDir, compileFlags, march, inputArgs), echoCmd=options.verbose)
    if retval != 0: cleanup_and_exit(retval)
    return output_files

def compile_to_bitcode(input_files):    
    bc_files = []
    compileFlags = ""
    compileFlags += "-O" + str(options.optimization_level) + " "
    if not options.tce_build_mode:
        compileFlags += newlibIncludes() + " "
    if options.g_cc_switch:
        compileFlags += "-g "
    for i in options.include_dirs:
        compileFlags += "-I" + i + " "
    for i in options.defines:
        compileFlags += "-D" + i + " "
    if options.unroll_threshold == 0:
        compileFlags += " -fno-unroll-loops"

    for i in options.f_cc_switches:
        if True:
            # Some of the gcc -f flags not supported by clang,
            # just skip them silently for now for gcc compatibility.
            if i == "short-enums": continue
        compileFlags += "-f" + i + " "

    for i in options.isystem_cc_switches:
        compileFlags += "-isystem" + i + " "

    tceOpsDir = tempDir + "/tceops.h"
    compileFlags += "-include " + tceOpsDir + " "

    for w in options.warnings:
        # Types of warnings supported by the compiler:
        white_list = []
        if True:
            white_list = ['no-empty-body',
                          'no-dangling-else',
                          'no-unknown-warning-option',
                          'no-bad-literal',
                          'no-literal-range',
                          'no-pointer-sign',
                          'no-return-type',
                          'no-unused-value',
                          'no-ignored-qualifiers',
                          'no-incompatible-pointer-types-discards-qualifiers',
                          'no-implicit-function-declaration']
        if w in white_list:
            compileFlags += "-W" + w + " "

    # generate tceops.h
    if runningInstalled:
        tceopgen = "tceopgen"
    else:
        tceopgen = "@abs_top_builddir@" + "/src/bintools/Compiler/tceopgen/tceopgen"
    
    exitCode = run_command(
        tceopgen + " -o " + tempDir + "/tceops.h" , echoCmd=options.verbose)

    if exitCode != 0:
        exitWithError(1, "Error while generating custom operation macros:\n")

    for input_file in input_files:
        bc_file = create_temp_file(input_file.replace("/", ".") + ".bc")
        march = "-march=rv32i"
        if hasMExtension :
            march += "m"
        retval = \
            run_command("clang -D__OA_RISCV__ -I %s %s -target riscv32 %s -c -emit-llvm %s -o %s" % \
            (tempDir, compileFlags, march, input_file, bc_file), echoCmd=options.verbose)

        if retval != 0: cleanup_and_exit(retval)
        bc_files.append(bc_file)

    bc_file = create_temp_file(".whole-program.bc")

    retval = run_command("llvm-link %s -o %s" % (" ".join(bc_files), bc_file), echoCmd=options.verbose)
    opt_bc_file = optimizeBytecode(bc_file)
    if retval != 0: cleanup_and_exit(retval)

    return opt_bc_file

def generate_code(bc_file, adf, objectCode=True, output=None):
    if runningInstalled:
        lib_tce = str(os.path.join(tceprefix, "lib/libopenasip.so"))
    else:
        lib_tce = os.path.join("@abs_top_builddir@", "src/.libs/libopenasip.so")
    if output is None:
        asm_file = create_temp_file(".o")
    else:
        asm_file = output
    fileType = "--filetype=obj"
    if objectCode == False :
        fileType = "--filetype=asm"
    retval = run_command("llc %s -load %s -adf %s %s -o %s" %
    (fileType, lib_tce, adf,  bc_file, asm_file),echoCmd=options.verbose)
    if retval != 0: cleanup_and_exit(retval)
    return [asm_file] 


def link(obj_files, output):
    if which("ld.lld") is None:
        exitWithError("lld must be installed for linking")
    if which("riscv32-unknown-elf-gcc") is None:
        exitWithError("RISCV GNU Toolchain must be installed")
    init_asm = os.path.join(tempDir, "init.S")
    init_out = os.path.join(tempDir, "init.o")
    link_script = os.path.join(tempDir, "riscv.ld")
    retval = run_command("clang -D__OA_RISCV__ -march=rv32i  -target riscv32 -c %s -o %s" % (init_asm, init_out))
    obj_files = " ".join(obj_files)
    if retval != 0: cleanup_and_exit(retval)
    lib_names = ""
    lib_dirs = ""
    for lib_name in options.lib_name:
        lib_names += "-l" + lib_name + " "
    for lib_dir in options.lib_dir:
        lib_dirs += "-L " + lib_dir + " "

    extra_flags = stdLibFlags()

    retval = run_command("ld.lld -lc -lm -lgcc  %s %s %s -Ttext=0 -T %s %s %s -o %s" %
    (lib_names, lib_dirs, extra_flags, link_script, init_out, obj_files, output), echoCmd=options.verbose)

    if retval != 0: cleanup_and_exit(retval)
    return output

def generate_linker_script(options):
    root = ET.parse(options.adf)
    found_instr = False
    found_data = False
    instr_start = 0
    data_start = 0
    data_end = 0
    root = ET.parse(options.adf)
    address_spaces = root.findall(".//*[min-address]")
    for i in range(len(address_spaces)):
        if address_spaces[i].attrib["name"] == "instructions":
            minAddr = address_spaces[i].find("min-address")
            if minAddr == None:
                exitWithError("Address space 'instructions' missing min-address tag")
            instr_start = minAddr.text
            found_instr = True
            continue
        elif address_spaces[i].attrib["name"] == "data":
            minAddr = address_spaces[i].find("min-address")
            maxAddr = address_spaces[i].find("max-address")
            if minAddr == None:
                exitWithError("Address space 'data' missing min-address tag")
            if maxAddr == None:
                exitWithError("Address space 'data' missing max-address tag")
            data_start = minAddr.text
            data_end = str(int(maxAddr.text) - 3)
            found_data = True
    if found_data == False:
        exitWithError("Could not find address space named 'data'")
    if found_instr == False:
        exitWithError("Could not find address space named 'instructions'")
    if int(instr_start) % 4 != 0:
        exitWithError("Address space 'instructions' start address not word aligned")
    if int(data_start) % 4 != 0:
        exitWithError("Address space 'data' start address not word aligned")
    if int(data_end) % 4 != 0:
        exitWithError("Address space 'data' end address not word aligned")
    linker_script = "ENTRY(_start)\n"\
    "__mem   = " + str(instr_start) + ";\n"\
    "__stack = " + str(data_end) + ";\n"\
    "__global = " + str(data_start) + ";\n"\
    "_end = " + str(data_start) + ";\n"\
    "\n"\
    "SECTIONS\n"\
    "{\n"\
    "    . = __mem;\n"\
    "    .text : {\n"\
    "        *(.text*)\n"\
    "    }\n"\
    "\n"\
    "    .data : {\n"\
    "        *(.sbss)\n"\
    "        *(COMMON)\n"\
    "        *(.bss)\n"\
    "        *(.sdata)\n"\
    "        *(.rodata)\n"\
    "        *(.data*)\n"\
    "        *(.got*)\n"\
    "    }\n"\
    "}"
    file_path = os.path.join(tempDir, "riscv.ld")
    text_file = open(file_path, "w")
    text_file.write(linker_script)
    text_file.close()

def generate_start_func():
    start_func =  ".global _start\n"\
    ".global __global\n"\
    ".global __stack\n"\
    ".global end\n"\
    ".section .text\n"\
    "_start:\n"\
    "   la    t0, __global\n"\
    "   la    sp, __stack\n"\
    "   call  main\n"\
    "end:\n"\
    "   j end\n"
    file_path = os.path.join(tempDir, "init.S")
    text_file = open(file_path, "w")
    text_file.write(start_func)
    text_file.close()

def generate_image(options, elf_file, final_output):
    if which("riscv32-unknown-elf-elf2hex") is None:
        exitWithError("elf2hex must be installed for \
        generating RISC-V images as a text file")
    hex_file = final_output
    if options.output_format == "bin":
        hex_file = create_temp_file(".hex")
    if options.output_format == "bin" or options.output_format == "hex":
        run_command("riscv32-unknown-elf-elf2hex --bit-width 32 \
        --input " + elf_file + " > " + hex_file)
        if options.output_format == "bin":
            run_command("oa-hex2bin \
            -w 32 -o " + final_output + " " + hex_file)

if __name__ == "__main__":
    options, args = parse_options()
    global tempDir
    tempDir = mkdtemp("","oacc-")
    if options.adf is None:
        adf = os.path.join("@abs_top_builddir@",
                                 "data/mach/rv32im.adf")
        options.adf = adf
    if len(args) == 0:
        exitWithError(1, "No input files given")

    final_output = options.output
    if options.output is None:
        final_output = "a.out"
        
    if not options.compile_only:
        generate_start_func()
        generate_linker_script(options)

    elf_file = final_output
    if options.output_format == "bin" or options.output_format == "hex":
        elf_file = create_temp_file(".hex")

    isAsm = False
    pieces = args[0].split(".")
    extension = pieces.pop()

    if extension == "S" or extension == "s":
        isAsm = True

    obj_file = ""
    if isAsm is False:
        bc_file = compile_to_bitcode(args)
        if options.compile_only:
            generate_code(bc_file, options.adf, True, final_output)
            cleanup_and_exit(0)
        obj_files = generate_code(bc_file, options.adf, True)
    else:
        if options.compile_only:
            asmFile = assemble(args, final_output)
            cleanup_and_exit(0)
        else:
            obj_files = assemble(args)
            additionalTmpFiles.extend(obj_files)
    
    #Link with generated start and linker script
    link(obj_files, elf_file)
    if options.output_format == "bin" or options.output_format == "hex":
        generate_image(options, elf_file, final_output)

    cleanup_and_exit(0)
