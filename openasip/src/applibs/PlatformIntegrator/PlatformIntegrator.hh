/*
    Copyright (c) 2002-2010 Tampere University.

    This file is part of TTA-Based Codesign Environment (TCE).

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
 */
/**
 * @file PlatformIntegerator.hh
 *
 * Declaration of PlatformIntegrator class.
 *
 * @author Otto Esko 2010 (otto.esko-no.spam-tut.fi)
 * @note rating: red
 */

#ifndef TTA_PLATFORM_INTEGRATOR_HH
#define TTA_PLATFORM_INTEGRATOR_HH

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "MemoryGenerator.hh"
#include "ProGeTypes.hh"

namespace ProGe {
    class Netlist;
    class NetlistBlock;
    class NetlistPort;
}

namespace TTAMachine {
    class Machine;
    class FunctionUnit;
    class AddressSpace;
}

namespace IDF {
    class MachineImplementation;
}

namespace HDB {
    class FUEntry;
}

class ProjectFileGenerator;

class PlatformIntegrator {
public:
    
    PlatformIntegrator();

    PlatformIntegrator(
        const TTAMachine::Machine* machine,
        const IDF::MachineImplementation* idf,
        ProGe::HDL hdl,
        TCEString progeOutputDir,
        TCEString coreEntityName,
        TCEString outputDir,
        TCEString programName,
        int targetClockFreq,
        std::ostream& warningStream,
        std::ostream& errorStream,
        const MemInfo& imem,
        MemType dmemType);

    virtual ~PlatformIntegrator();

    /**
     * Integrates the TTA core(s) generated by ProGe
     *
     * @param progeBlock The toplevel netlist block created by ProGe
     */
    virtual void integrateProcessor(
        const ProGe::NetlistBlock* progeBlock) = 0;

    /**
     * Returns the FPGA device family
     */
    virtual TCEString deviceFamily() const = 0;

    /**
     * Set the FPGA device family.
     *
     * Intended for TTA IP integration. Integrator can device whether this
     * overrides the default device family.
     */
    virtual void setDeviceFamily(TCEString devFamily) = 0;

    /**
     * Set or get the FPGA device name.
     *
     * This is used for synthesis scripts by AlmaIFIntegrator
     * and QuartusProjectGenerator.
     */
    void setDeviceName(TCEString devName) { deviceName_ = devName; }
    TCEString deviceName() const { return deviceName_; }


    /**
     * Returns the device package name
     */
    virtual TCEString devicePackage() const = 0;

    /**
     * Returns the device speed class
     */
    virtual TCEString deviceSpeedClass() const = 0;


    /**
     * Returns the target clock frequency in MHz
     */
    virtual int targetClockFrequency() const;

    /**
     * Prints information about the platform
     */
    virtual void printInfo(std::ostream& stream) const = 0;

    
    /**
     * Returns the netlist block created by ProGe which contains the tta cores
     */
    const ProGe::NetlistBlock& progeBlock() const;

    /**
     * Returns the platform integration toplevel netlist block
     */
    const ProGe::NetlistBlock& toplevelBlock() const;

    /**
     * Set proge share output directory if it differs from ProGe output dir
     */
    void setSharedOutputDir(const TCEString& sharedDir);

    /**
     * Returns the platform integrator output path string. Might not exist.
     *
     * @return Platform Integrator output path
     */
    TCEString outputPath() const;

    /**
     * Returns string to the platform integrator output path of the fileName
     *
     * @param filename Name of file
     * @param absolute Return absolute path
     * @return Path to file
     */
    TCEString outputFilePath(TCEString fileName, bool absolute = false) 
        const;

    /**
     * Return TTA core entity name
     */
    TCEString coreEntityName() const;

    const TTAMachine::Machine* machine() const;

    const IDF::MachineImplementation* idf() const;
    
    const MemInfo& imemInfo() const;
    
    const MemInfo& dmemInfo(TTAMachine::AddressSpace* as) const;

    const MemInfo& dmemInfo(int index) const;

    int dmemCount() const;

    ProGe::NetlistPort* clockPort() const;

    ProGe::NetlistPort* resetPort() const;

protected:

    ProGe::NetlistBlock* integratorBlock();

    /**
     * Initializes the platform integrator netlist
     *
     * Copies a TTA core to a new netlist, adds clock and reset ports to
     * the new netlist.
     *
     * @param progeBlock The toplevel netlist block created by ProGe
     */
    virtual void initPlatformNetlist(const ProGe::NetlistBlock* progeBlock);

    /**
     * Integrates a single TTA core
     *
     *
     * @param cores NetlistBlock containing the core(s)
     * @param coreId Index of the core to be integrated
     */
    virtual bool integrateCore(const ProGe::NetlistBlock& cores, int coreId);

    virtual void exportUnconnectedPorts(int coreId);

    virtual void connectToplevelPort(const ProGe::NetlistPort& corePort,
                                     const TCEString signalPrefix = "");

    virtual TCEString pinTag() const = 0;

    virtual bool chopTaggedSignals() const = 0;

    virtual bool hasPinTag(const TCEString& signal) const;

    /**
     * Copies the ProGe generated toplevel block (i.e. tta core(s)) to a
     * new netlist.
     *
     * @param progeBlock The toplevel netlist block created by ProGe
     */
    void copyProgeBlockToNetlist(const ProGe::NetlistBlock* progeBlock);

    virtual bool createMemories(int coreId);

    virtual bool generateMemory(
        MemoryGenerator& memGen,
        std::vector<TCEString>& generatedFiles,
        int memIndex,
        int coreId);

    virtual MemoryGenerator& imemInstance(MemInfo imem, int coreId) = 0;

    virtual MemoryGenerator& dmemInstance(
        MemInfo dmem,
        TTAMachine::FunctionUnit& lsuArch,
        std::vector<std::string> lsuPorts) = 0;

    virtual void writeNewToplevel();

    virtual ProjectFileGenerator* projectFileGenerator() const = 0;

    void addProGeFiles() const;

    /**
     * Returns the scheduled program name without .tpef ending
     */
    TCEString programName() const;

    /**
     * Returns string to the proge-output path of the fileName
     *
     * @param filename Name of file
     * @param absolute Return absolute path
     * @return Path to file
     */
    TCEString
    progeFilePath(TCEString fileName, bool absolute = false) const;

    /**
     * Utility function for processing vhdl signals.
     *
     * Signal name format is fu_name_<TAG>_name : <dir> <type> {);}
     * This function chops the signal name in such way that the name starts
     * from <TAG> i.e. returns <TAG>_name : <dir> <type> {);}
     *
     * @param original Original signal name
     * @param tag Starting tag
     * @return Chopped string
     */
    TCEString chopSignalToTag(
        const TCEString& original, const TCEString& tag) const;

    /**
     * Appends all the vhdl files from ProGe output directory's vhdl and
     * gcu_ic subdirectories to the given vector.
     *
     * @param files Vector where the filenames are appended to.
     */
    void progeOutputHdlFiles(std::vector<TCEString>& files) const;

    std::ostream& warningStream() const;

    std::ostream& errorStream() const;

    TCEString platformEntityName() const;

    void parseDataMemories();
    void clearDataMemories();

    MemInfo readLsuParameters(const TTAMachine::FunctionUnit& lsu);

    static const TCEString TTA_CORE_CLK;
    static const TCEString TTA_CORE_RSTX;

private:

    void createOutputDir();

    std::vector<std::string> loadFUExternalPorts(
        TTAMachine::FunctionUnit& fu) const;

    const TTAMachine::Machine* machine_;

    const IDF::MachineImplementation* idf_;

    ProGe::NetlistBlock* integratorBlock_;
    
    ProGe::HDL hdl_;
    
    TCEString progeOutputDir_;
    TCEString sharedOutputDir_;
    TCEString coreEntityName_;
    TCEString outputDir_;
    TCEString programName_;
    TCEString deviceName_;
    int targetFrequency_;

    std::ostream& warningStream_;
    std::ostream& errorStream_;

    ProGe::NetlistBlock* ttaCores_;

    MemInfo imem_;
    MemType dmemType_;
    std::map<TTAMachine::AddressSpace*, MemInfo> dmem_;

    std::vector<TTAMachine::FunctionUnit*> lsus_;

    ProGe::NetlistPort* clkPort_;
    ProGe::NetlistPort* resetPort_;

    std::multimap<TCEString, const ProGe::NetlistPort*>* unconnectedPorts_;
};
#endif
