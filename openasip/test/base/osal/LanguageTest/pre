#!/bin/sh
#
# Views the code generated by an operation definition which uses
# the OSAL "behavior description language".
#
# Tries to add new lines in some places to make the result more readable.
#
# @author Pekka J‰‰skel‰inen 2004 (pjaaskel@cs.tut.fi)

if [ "x$1" == "x" ];
    then
    echo "Source file required as argument."
    exit 1
fi

source=$1

# Returns nonzero if sed provided by the system does not support \n in
# the output. 
#
# If \n is not supported then newlines are tried to be generated 
# with \<newline> sequence, in which <newline> is real newline character 
# (produced with enter in the editor).
function SedSupportsEscapedNewline {
    sedVersion=`sed --version | head -1 | cut -c 17-20`
    if [ "x$sedVersion" == "x3.02" ];
	then
	return 1; # Sed used in Debian Stable doesn't support \n in the output
    fi
    return 0; # \n should be supported
}

ourFileFound=0
function PrintIfOurFileFound {
    while read line;
      do

      # We wait until we found the second occurence of $source.
      #
      # First occurence is the entry point when cpp starts to process $source,
      # after that comes huge pile of includes which we are not interested of.
      #
      # Second occurence should be the file itself.
      if test $ourFileFound -gt 1; 
	  then
	  echo "$line"
	  continue
      fi
      
      if test -z "$line";
	  then 
	  continue
      fi


      found=`echo \"$line\" | grep \"$source\"`

      if test -n "$found";
	  then
	  let "ourFileFound++"
      fi
    done
}

srcRoot="../../../../"
inputCmd="cpp -C -I$srcRoot -I$srcRoot/src/tools -I$srcRoot/src/base/memory \
-I$srcRoot/src/base/osal $*"

if SedSupportsEscapedNewline;
    then

$inputCmd |\
    sed -e 's/{/{\n/g' -e 's/}/}\n\n/g' -e 's/;/;\n/g' \
        -e 's/public:/\npublic:\n/g' -e 's/private:/\nprivate:\n/g' |\
    PrintIfOurFileFound

else

$inputCmd |\
    sed -e 's/{/{\
/g' -e 's/}/}\
\
/g' -e 's/;/;\
/g' \
        -e 's/public:/\
public:\
/g' -e 's/private:/\
private:\
/g' | PrintIfOurFileFound


fi